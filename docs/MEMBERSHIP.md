# Membership Proofs

Restrict authentication to users who belong to groups you define.

---

## What It Is

Membership proofs let you verify a user belongs to a specific group without revealing which member they are. This enables:

- **Employee SSO** - Only your employees can log in
- **Premium tiers** - Restrict features to paying customers
- **Age verification** - Prove once, access many sites
- **KYC'd users** - Verify identity once, reuse everywhere
- **Anti-sybil** - One account per verified human
- **Communities** - Conference attendees, Discord members, etc.

**Key insight:** SignedByMe stores and proves membership. Verification (ID check, payment, HR approval) is YOUR responsibility before enrollment.

---

## How It Works

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  SETUP (once per user)                                              │
│  ─────────────────────                                              │
│                                                                     │
│  1. User passes YOUR verification                                   │
│     (ID check, payment, HR adds them, etc.)                         │
│                                                                     │
│  2. You enroll their DID in your Merkle tree                        │
│     POST /v1/membership/enroll                                      │
│                                                                     │
│  3. You publish the updated root                                    │
│     POST /v1/roots/publish                                          │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  LOGIN (every time)                                                 │
│  ──────────────────                                                 │
│                                                                     │
│  4. User proves membership via Merkle proof                         │
│     (app does this automatically)                                   │
│                                                                     │
│  5. API verifies: "This DID is in Acme's employee tree"             │
│                                                                     │
│  6. ID token includes membership claims                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Concepts

### Merkle Tree

A cryptographic data structure where:
- Each **leaf** is a user's commitment (derived from their DID)
- The **root** is a single hash representing ALL members
- A **witness** (proof) shows a leaf is part of the tree WITHOUT revealing other leaves

```
              Root Hash
             /         \
         Hash01       Hash23
         /    \       /    \
      Hash0  Hash1  Hash2  Hash3
        │      │      │      │
      User0  User1  User2  User3  (leaf commitments)
```

To prove User2 is in the tree, they only need: `[Hash3, Hash01]` + their position.

### Purpose ID

A string identifying what the tree represents:

| Purpose ID | Meaning |
|------------|---------|
| `employees` | Company employees |
| `contractors` | External contractors |
| `premium` | Paid subscribers |
| `age-verified` | Passed age check |
| `kyc` | Completed KYC |

You define your own purpose IDs. They're just strings.

### Root ID

Unique identifier for a specific version of your tree:

```
acme-employees-2024-02-19
{client}-{purpose}-{date or version}
```

When you add/remove members, publish a new root with a new ID.

---

## Setup: Creating Your Tree

### 1. Configure Your Client

When registering with SignedByMe, specify:

```json
{
  "client_id": "acme",
  "require_membership": true,
  "allowed_purposes": ["employees", "contractors"]
}
```

| Field | Description |
|-------|-------------|
| `require_membership` | If `true`, users MUST prove membership |
| `allowed_purposes` | Which purpose IDs are accepted (empty = any) |

### 2. Enroll Users

When a user passes your verification, enroll them:

```bash
POST /v1/membership/enroll
{
  "client_id": "acme",
  "purpose_id": "employees",
  "leaf_commitment": "abc123..."
}
```

The `leaf_commitment` is generated by the user's app during onboarding. It's derived from their DID but can't be reversed to reveal it.

**Where does leaf_commitment come from?**
- User completes SignedByMe app setup (creates DID)
- App generates `leaf_commitment = hash(DID || secret)`
- User provides this to your enrollment system
- You submit it to SignedByMe

### 3. Publish the Root

After enrolling users, publish the updated root:

```bash
POST /v1/roots/publish
{
  "root_id": "acme-employees-2024-02",
  "root_hash": "def456...",
  "purpose_id": "employees"
}
```

**Note:** SignedByMe can auto-build roots from enrolled members, or you can compute and publish your own.

---

## Integration Patterns

### Pattern A: Admin Enrollment

**Best for:** Employees, contractors, approved vendors

```
┌────────────┐      ┌────────────┐      ┌────────────┐
│  HR System │      │ Your Server│      │ SignedByMe │
└─────┬──────┘      └─────┬──────┘      └─────┬──────┘
      │                   │                   │
      │ New employee      │                   │
      │ added             │                   │
      │──────────────────▶│                   │
      │                   │                   │
      │                   │ POST /enroll      │
      │                   │──────────────────▶│
      │                   │                   │
      │                   │ POST /roots/publish
      │                   │──────────────────▶│
      │                   │                   │
```

### Pattern B: Self-Enrollment with Verification Gate

**Best for:** Age verification, KYC, premium subscriptions

```
┌────────────┐      ┌────────────┐      ┌────────────┐      ┌────────────┐
│   User     │      │  Persona   │      │ Your Server│      │ SignedByMe │
│   App      │      │  (ID svc)  │      │            │      │            │
└─────┬──────┘      └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
      │                   │                   │                   │
      │ Submit ID scan    │                   │                   │
      │──────────────────▶│                   │                   │
      │                   │                   │                   │
      │                   │ Webhook: verified │                   │
      │                   │──────────────────▶│                   │
      │                   │                   │                   │
      │                   │                   │ POST /enroll      │
      │                   │                   │──────────────────▶│
      │                   │                   │                   │
      │ "You're verified" │                   │                   │
      │◀─────────────────────────────────────│                   │
      │                   │                   │                   │
```

### Pattern C: Payment-Gated Enrollment

**Best for:** Premium tiers, subscriptions

```
┌────────────┐      ┌────────────┐      ┌────────────┐      ┌────────────┐
│   User     │      │  Stripe    │      │ Your Server│      │ SignedByMe │
└─────┬──────┘      └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
      │                   │                   │                   │
      │ Pay $9.99/mo      │                   │                   │
      │──────────────────▶│                   │                   │
      │                   │                   │                   │
      │                   │ Webhook: paid     │                   │
      │                   │──────────────────▶│                   │
      │                   │                   │                   │
      │                   │                   │ POST /enroll      │
      │                   │                   │  (premium tree)   │
      │                   │                   │──────────────────▶│
      │                   │                   │                   │
```

---

## Managing Members

### Adding Members

```bash
POST /v1/membership/enroll
{
  "client_id": "acme",
  "purpose_id": "employees",
  "leaf_commitment": "abc123..."
}
```

### Removing Members

To remove a member, publish a new root WITHOUT their leaf:

1. Rebuild your tree excluding the removed user
2. Publish the new root:

```bash
POST /v1/roots/publish
{
  "root_id": "acme-employees-2024-02-v2",
  "root_hash": "newroot...",
  "purpose_id": "employees"
}
```

The old root becomes inactive. Users not in the new tree can no longer prove membership.

### Checking Membership

Users fetch their witness proof to verify they're still enrolled:

```bash
GET /v1/membership/witness?client_id=acme&purpose_id=employees&leaf_commitment=abc123
```

If they're not in the current tree, this returns 404.

---

## Login Flow with Membership

### User's App Does:

1. Fetch witness proof for the client's tree
2. Include witness in login submission
3. App handles this automatically when membership is required

### API Verifies:

1. Merkle proof is valid (path hashes correctly to root)
2. Root is published and active for this client
3. Purpose matches client's `allowed_purposes`

### ID Token Includes:

```json
{
  "iss": "https://api.beta.privacy-lion.com",
  "sub": "did:key:z6MkhaXgBZD...",
  "aud": "acme",
  "amr": ["did_sig", "stwo_proof", "ln_payment", "merkle"],
  
  "https://signedby.me/claims/membership_verified": true,
  "https://signedby.me/claims/membership_purpose": "employees",
  "https://signedby.me/claims/membership_root_id": "acme-employees-2024-02"
}
```

Check for `"merkle"` in `amr` to confirm membership was verified.

---

## Multiple Trees

A single client can have multiple trees for different purposes:

```json
{
  "client_id": "acme",
  "require_membership": true,
  "allowed_purposes": ["employees", "contractors", "vip-customers"]
}
```

Users can be in multiple trees. The ID token shows which tree they proved membership in.

**Example:** Restrict admin panel to employees only:

```python
def require_employee(token):
    if "merkle" not in token["amr"]:
        raise Unauthorized("Membership required")
    if token["https://signedby.me/claims/membership_purpose"] != "employees":
        raise Forbidden("Employees only")
```

---

## Privacy Properties

### What the Verifier Learns
- User is in the tree (yes/no)
- Which purpose (e.g., "employees")
- Which root (specific version)

### What the Verifier Does NOT Learn
- User's position in the tree
- Who else is in the tree
- User's leaf commitment (hidden by ZK proof)

### What Other Members Learn
- Nothing about each other

This enables privacy-preserving membership proofs. A site can verify "this user is age-verified" without learning their name, birthdate, or which ID service verified them.

---

## Example Use Cases

### Employee SSO

```python
# Enrollment (when HR adds employee)
def onboard_employee(employee_did_commitment):
    requests.post(f"{API}/v1/membership/enroll", json={
        "client_id": "acme",
        "purpose_id": "employees",
        "leaf_commitment": employee_did_commitment
    })

# Verification (at login)
def verify_employee(id_token):
    claims = decode_jwt(id_token)
    return (
        "merkle" in claims["amr"] and
        claims["https://signedby.me/claims/membership_purpose"] == "employees"
    )
```

### Age-Gated Content

```python
# After Persona verifies user is 18+
@app.route("/persona-webhook", methods=["POST"])
def persona_verified(data):
    if data["status"] == "approved":
        requests.post(f"{API}/v1/membership/enroll", json={
            "client_id": "yoursite",
            "purpose_id": "age-verified",
            "leaf_commitment": data["user_commitment"]
        })

# At content access
def require_age_verified(id_token):
    claims = decode_jwt(id_token)
    if not claims.get("https://signedby.me/claims/membership_verified"):
        redirect("/verify-age")
```

### Premium Tier

```python
# After Stripe subscription confirmed
@app.route("/stripe-webhook", methods=["POST"])
def subscription_created(event):
    if event["type"] == "customer.subscription.created":
        requests.post(f"{API}/v1/membership/enroll", json={
            "client_id": "yourapp",
            "purpose_id": "premium",
            "leaf_commitment": get_user_commitment(event["customer"])
        })

# Feature gating
def premium_only(id_token):
    claims = decode_jwt(id_token)
    return claims.get("https://signedby.me/claims/membership_purpose") == "premium"
```
